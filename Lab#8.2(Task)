Строки и форматирование
Тип данных «строка» — это тоже коллекция. Элементами этой коллекции служат символы, составляющие строку.

Строку, как и любую коллекцию, можно обрабатывать в цикле, извлекать из неё элементы или группы элементов и преобразовывать в другие типы коллекций.

Строку можно преобразовать в список или сет.

Запустите код

string = 'По Борнео и Ямайке ходит слон в трусах и майке'
new_list = list(string)
new_set = set(string)
print('Список из строки: ' + str(new_list))
print('Сет из строки: ' + str(new_set))
Преобразование строки в list никаких неожиданностей не принесёт: получится список, каждым элементом которого будет буква.

А при создании сета:

из строки исключены дублирующиеся символы;
при печати элементы выводятся в случайном порядке.
Буквы под номерами: индексы
Строка — упорядоченная коллекция, иначе каждый раз при печати выводилась бы нечитаемая чепуха, где все буквы перепутаны.

К элементам строки (к буквам) можно обратиться по индексу, точно так же, как и к элементам списка. Например, по индексу [4] из строки 'Я пишу стихи на Python' будет получена буква ш.

Похулиганим немного:

соберём индексы определённых букв (их порядковые номера) в список index_list;
пройдёмся по этому списку в цикле и напечатаем буквы, соответствующие индексам.
Запустите код:

monument_string = 'Я памятник себе воздвиг нерукотворный'

index_list = [0, 1, 2, 8, 6, 17, 24]

for i in index_list:
    # На каждой итерации цикла 
    # берём из строки monument_string элемент с индексом i и печатаем полученную букву
    print(monument_string[i])
Отрицательные индексы
Иногда бывает необходимо обратиться к элементам коллекции, начиная отсчёт с конца. В таких случаях применяют отрицательные индексы: последний элемент коллекции можно получить по индексу [-1], предпоследний — по индексу [-2], и так далее.

Это касается и строк, и любых упорядоченных коллекций.

Запустите Код:

# Обратимся к элементам списка по отрицательным индексам
friends = ['Сергей', 'Соня', 'Миша', 'Дима', 'Алина']
print(friends[-3])  # Миша
print(friends[-5])  # Сергей

# То же и со строкой
monument_string = 'Я памятник себе воздвиг нерукотворный'
print(monument_string[-2])   # ы
print(monument_string[-37])  # Я
Разобрать строку на слова: метод split()
Строку можно разделить на слова или на другие фрагменты текста — и сохранить получившиеся подстроки в список. Это делает метод split().

Для этого метода можно указать аргумент — разделитель, по которому строка будет разбита на части. Разделителем может быть цифра, буква, пробел или любой набор символов.

Например, если к строке 'молоковоз' применить метод split() с аргументом 'о' — то результатом будет список ['м', 'л', 'к', 'в', 'з']. При этом сам разделитель вырезается из строки.

milk_str = 'молоковоз'

# Применяем метод split() с аргументом 'о':
new_list = milk_str.split('о')

print(new_list)
# Будет напечатано: ['м', 'л', 'к', 'в', 'з']
Запустите код:

counter_str = 'Раз-два-три-четыре-пять, вышел зайчик погулять'

# Преобразуем строку в список, а разделителем будет дефис
counter_list = counter_str.split('-')
print(counter_list)

# Создадим ещё одну строку
blok_str = 'Ночь. Улица. Фонарь. Аптека'
# Разобьём фразу по словам. 
# Разделителем будет служить сочетание точки и пробела:
blok_list = blok_str.split('. ')
print(blok_list)
Чтобы разделить строку на слова — в качестве разделителя нужно указать пробел, это такой же символ, как буква или цифра.

Если аргументом метода split() будет пробел — то фраза, к которой будет применён этот метод, будет разбита на отдельные слова:

Запустите код:

poem_str = 'Дама сдавала багаж'

# Применяем к строке метод split(), в скобках указываем пробел в кавычках:
words_list = poem_str.split(' ')
# Печатаем результат:
print(words_list)
Python нашёл в строке пробелы, воспринял их как разделители, разбил строку на части и создал список из получившихся элементов; каждый элемент этого списка — это строка, слово из исходной фразы.

Если вызвать метод split() без аргументов, с пустыми скобками — он точно так же разобьёт строку по пробелам.

Следовательно, чтобы разбить строку на отдельные слова по пробелам — не обязательно указывать аргумент; код words_list = poem_str.split(' ') даст тот же результат, что и words_list = poem_str.split(). Но если между словами стоит более одного пробела — результат применения split() и split(' ') будет отличаться. Попробуйте.

А зачем разбирать строку?
Метод split() может пригодиться, например, для поиска определённых слов в полученном тексте.

Текст можно преобразовать в список слов, проверить, есть ли определённое слово в этом списке, и если есть — выполнить нужные действия.

Например, в офис провайдера приходит сообщение от клиента.

message = 'У меня опять всё сломалось и не работает соединение с интернетом!!11'

# Разбиваем сообщение по пробелам на слова
words = message.split()
# Проверяем, есть ли ключевые слова в письме
if 'стоимость' in words:
    print('Переслать письмо в отдел биллинга')
elif 'сломалось' in words:
    print('Переслать письмо в техподдержку')
else:
    print('Содержание письма не определено, придётся прочесть самостоятельно')
Если в тексте есть слово «стоимость» — сообщение нужно автоматически переслать в отдел биллинга; если есть слово «сломалось» — это в техподдержку, а если ключевые слова не найдены — то письмо придётся читать тому, на чей адрес оно пришло.

Набор ключевых слов можно расширить, и несложная программа-сортировщик писем заработает.

Создать строку из коллекции: метод join()
Можно выполнить и обратную процедуру: «смонтировать» строку из элементов списка. В получившейся строке можно разделить элементы исходного списка каким-нибудь текстовым символом или набором символов.

Эту операцию выполняет метод join().

Из элементов списка words_list создадим строку new_string и напечатаем её.

Обратите внимание, у метода join() синтаксис отличается от split(): метод применяется к строке-разделителю, а список передаётся как аргумент метода.

Разделителем может быть любая строка: какое-нибудь слово, запятая с пробелом ', ', пробел ' ', а может быть «пустая строка» '' — кавычки, между которыми ничего нет, даже пробела.

Запустите код несколько раз, замените разделитель - на какой-нибудь другой: посмотрите, как работает этот метод.

words_list = ['раз', 'два', 'три', 'четыре', 'пять', 'вышел', 'зайчик', 'погулять']
# Метод join() "склеивает" элементы списка,
# создавая строку, в которой 
# элементы исходного списка разделены текстовым символом;
# для разделения применим дефис:
new_string = '-'.join(words_list)

print(new_string)
Задача 1
Допишите код функции penult_word() так, чтобы она возвращала третье с конца слово из любой фразы, переданной в аргументе.

quote_1 = 'Работает? Не трогай'
quote_2 = 'Если твой код работает, значит это хороший код'
quote_3 = 'Лень - главное достоинство программиста'

def penult_word(message):
    word_list = ...
    return ...

# Вызовы функции готовы к работе, не изменяйте их!

# Вызываем функцию penult_word с аргументом quote_1 и печатаем результат её работы.
print(penult_word(quote_1))

# То же, но с аргументом quote_2.
print(penult_word(quote_2))

# То же с аргументом quote_3.
print(penult_word(quote_3))
Задача 2
В коде приготовлен список запросов к Анфисе queries. Необходимо определить, какие из них адресованы Анфисе, а какие — другим людям.

Напишите функцию check_query(), которая принимает запрос как параметр, анализирует его и возвращает одну из двух строк:

строку ‘запрос к Анфисе’, если запрос начинается со слова ‘Анфиса’,
или строку ‘запрос к кому-то ещё’, если запрос начинается с любого другого слова.
Код вызова функции и вывода результатов на экран уже написан в теле программы.

def check_query(query):
# Допишите код тела функции
    elements  = ...
    if ...
        return 'запрос к Анфисе'
    else:
        return 'запрос к кому-то ещё'



# Дальше следует код, вызывающий вашу функцию; не изменяйте его:
queries = [
    'Анфиса, сколько у меня друзей?',
    'Андрей, ну где ты был?',
    'Андрей, ну обними меня скорей!',
    'Анфиса, кто все мои друзья?'
]

# Напечатаем результат.
# Переберём список вопросов в цикле
for q in queries:
    # Каждый из вопросов передадим аргументом
    # в функцию check_query()
    result = check_query(q)
    # И для каждого вызова напечатаем вопрос и, через дефис - вердикт программы
    print(q, '-', result)
Задача 3
Анфиса научилась отличать своё имя от других. Теперь надо научить её извлекать суть запроса.

Перепишите функцию check_query() так, чтобы при любом запросе она «отрезала» от строки имя и возвращала только запрос, без имени.

Например, если Анфисе пришёл запрос «Толя, что это за ерунда?» — функция check_query() должна вернуть строку ‘что это за ерунда?’.

def check_query(query):
    elements  = query.split(', ')
    # Напишите код функции


# Дальше следует код, вызывающий вашу функцию; не изменяйте его:
queries = [
    'Анфиса, сколько у меня друзей?',
    'Андрей, ну где ты был?',
    'Андрей, ну обними меня скорей!',
    'Анфиса, кто все мои друзья?'
]

for q in queries:
    result = check_query(q)
    print(q, '—', result)
Задача 4
Упростим и улучшим код Анфисы.

При выводе перечня друзей или городов Анфиса применяет циклы, объединяя ключи или значения словаря в одну строку, через пробел.

Но теперь в вашем арсенале есть метод join(), он решает ту же задачу: создаёт строку из элементов последовательности.

Уберите из кода циклы, в которых создаётся перечень друзей и перечень городов, а эти перечни создайте с помощью метода join(). Имена друзей и названия городов должны быть разделены запятыми и пробелом.

# Анфиса должна вернуть примерно такие строки:
# В ответ на запрос 'Кто все мои друзья?'-
Твои друзья: Серёга, Соня, Миша, ...

# В ответ на запрос 'Где все мои друзья?' -
Твои друзья в городах: Омск, Москва, Челябинск, ... 
DATABASE = {
    'Серёга': 'Омск',
    'Соня': 'Москва',
    'Миша': 'Москва',
    'Дима': 'Челябинск',
    'Алина': 'Красноярск',
    'Егор': 'Пермь',
    'Коля': 'Красноярск'
}

def process_anfisa(query):
    if query == 'Сколько у меня друзей?':
        count = len(DATABASE)
        
        return 'У тебя ' + str(count) + ' друзей.'
    elif query == 'Кто все мои друзья?':
        # Из словаря DATABASE создайте строку с помощью join();
        # имена друзей разделите запятой и пробелом.
        # Запишите эту строку в переменную friends_string (вместо пустых кавычек).
        friends_string = ''

        # Этот цикл больше не понадобится, удалите его
        for friend in DATABASE:
            friends_string += friend + ' '

        return 'Твои друзья: ' + friends_string
    elif query == 'Где все мои друзья?':
        unique_cities = set(DATABASE.values())
        # Из сета unique_cities создайте строку с помощью join();
        # названия городов разделите запятой и пробелом.
        # Запишите эту строку в переменную cities_string (вместо пустых кавычек).
        cities_string = ''

        # Этот цикл больше не понадобится, удалите его
        for city in unique_cities:
            cities_string += city + ' '

        return 'Твои друзья в городах: ' + cities_string
    else:
        return '<неизвестный запрос>'


print('Привет, я Анфиса!')
print(process_anfisa('Сколько у меня друзей?'))
print(process_anfisa('Кто все мои друзья?'))
print(process_anfisa('Где все мои друзья?'))
