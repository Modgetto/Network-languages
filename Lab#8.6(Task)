Python вместо браузера
Общаться с серверами в интернете умеют не только браузеры. Можно написать собственный клиент на Python, используя библиотеку requests. Например, с помощью вашего первого программного веб-клиента можно отправить GET-запрос к первому в мире веб-сайту:

# Импортируем библиотеку:
import requests

# Отправляем GET-запрос:
response = requests.get('http://info.cern.ch/')

print(response.text)  # Печатаем код запрошенной страницы.
При запуске этой программы будет напечатан HTML-код запрошенной страницы:

<html><head></head><body><header>
<title>http://info.cern.ch</title>
</header>

<h1>http://info.cern.ch - home of the first website</h1>
<p>From here you can:</p>
<ul>
<li><a href="http://info.cern.ch/hypertext/WWW/TheProject.html">Browse the first website</a></li>
<li><a href="http://line-mode.cern.ch/www/hypertext/WWW/TheProject.html">Browse the first website using the line-mode browser simulator</a></li>
<li><a href="http://home.web.cern.ch/topics/birth-web">Learn about the birth of the web</a></li>
<li><a href="http://home.web.cern.ch/about">Learn about CERN, the physics laboratory where the web was born</a></li>
</ul>
</body></html>
Прямо из Python-кода, без браузера, мы отправили запрос к веб-странице http://info.cern.ch/, вызвав метод get(). И прямо в коде получили HTTP-ответ от сервера.

HTTP-ответ представляет собой программный объект. Этот объект мы сохранили в переменную response. В свойстве text этого объекта хранится HTML-код запрошенной страницы. Чтобы распечатать код, мы передали свойство response.text аргументом в функцию print().

Сравните напечатанный результат с кодом этой страницы в браузерных Инструментах разработчика:



Всё логично. Написанный нами простой клиент получает в ответ то же самое, что и настоящий браузер!

Шпоргалка https://ftp.codimd.ru/f/e0090bce7efc4413af01/

import requests

url = 'http://wttr.in/?0T'

response = ...  # выполните HTTP-запрос

print(...)  # напечатайте текст HTTP-ответа
Передаём параметры в URL
Вспомним поисковый запрос к Яндексу из прошлой темы.

Результаты поиска были доступны по адресу:

https://yandex.ru/search/?text=что%20такое%20backend&lr=213
Как можно запросить эту же информацию из Python? Вроде бы всё уже известно, обращаемся по сети вот так:

url = 'https://yandex.ru/search/?text=%D1%87%D1%82%D0%BE%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B5%20backend&lr=213'
    
response = requests.get(url)
Но это не очень красиво.

Приходится вручную писать длинный URL, перечисляя все параметры. А что если бы их было больше?

Ещё приходится самим кодировать символы в URL, что совсем скучно.

К счастью, Python умеет удобно формировать адреса URL, подставляя в них параметры из словаря. Функция get() сама производит нужные преобразования, нужно лишь передать параметры через именованный аргумент params:

import requests

search_parameters = {
    'text': 'что такое backend',
    'lr': 213
}
url = 'https://yandex.ru/search/'
# Функция get() приняла на вход URL и параметры поиска,
# а дальше она знает, что делать
response = requests.get(url, params=search_parameters)

print(response.status_code)
print(response.url)
200
https://yandex.ru/search/?text=%D1%87%D1%82%D0%BE+%D1%82%D0%B0%D0%BA%D0%BE%D0%B5+backend&lr=213
Любимое число бэкендеров — это 200. Оно значит, что сервер всё понял и ответил как надо.

Бывают такие параметры, которым не нужно присваивать значение, а достаточно передать только имя. Например, параметр u сервиса wttr.in переведёт все величины в английскую систему мер (градусы Фаренгейта, мили, дюймы): http://wttr.in/?u . Для таких параметров в словаре в качестве значения указывается пустая строка.

import requests
    
        
parameters = {
    'u': '',
    'T': ''
}
url = 'http://wttr.in'

# параметры передаются через аргумент params
response = requests.get(url, params=parameters)

print(response.text)
Weather report: Moscow, Russia

     \   /     Sunny
      .-.      71..75 °F      
   ― (   ) ―   → 6 mph        
      `-’      6 mi           
     /   \     0.0 in
Задача №1
Запросите погодный сервис http://wttr.in по URL без параметров. А их задайте словарём weather_parameters. Функция get() должна принимать его, как отдельный аргумент params.

import requests


url = 'https://wttr.in'  # не изменяйте значение URL

weather_parameters = {
    '0': '',
    # добавьте параметр запроса `T`, чтобы вернулся чёрно-белый текст
}

response = ...  # передайте параметры в http-запрос

print(response.text)
Задача №2
Добавьте в словарь с параметрами weather_parameters ещё два параметра:

M без значения — чтобы скорость ветра была в метрах в секунду, как принято у метеорологов;
lang со значением ru, чтобы прогноз выдавался на русском языке.
Обратите внимание на изменения при добавлении этих параметров. О других параметрах можно прочитать в документации.

import requests


url = 'https://wttr.in'  # не изменяйте значение URL

weather_parameters = {
    '0': '',
    'T':''
    # добавьте параметр запроса `T`, чтобы вернулся чёрно-белый текст
}

response = requests.get(url, params=weather_parameters)  # передайте параметры в http-запрос

print(response.text)
Задача №3. Заголовки запросов и ответов.
На прошлом уроке вы заказывали страницу на русском языке через параметры в URL.

Сейчас сделайте то же самое, только русский язык запрашивайте через заголовок запроса ‘Accept-Language’.

import requests

url = 'https://wttr.in'

weather_parameters = {
    '0': '',
    'T': '',
    'lang': 'ru',  # удалите этот параметр
    'M': '',
}

request_headers = {
    # заполните словарь с заголовками
}

# не забудьте передать параметры и заголовки в http-запрос
# через аргументы `params` и `headers` функции get()
response = ...
print(response.text)
Обработка ошибок
Как и всё в этом мире, программы не идеальны. Они могут содержать ошибки. И что ещё печальнее, не все ошибки получается найти до запуска программы. Хуже того, не всегда они проявляются с первого раза — их возникновение может зависеть от внешних факторов, и тогда ошибки происходят в процессе выполнения программы.

Тогда ошибка так и называется runtime error. Этих ошибок целое семейство.

Пример:

import random

a = random.randint(0, 3)  # случайное целое число от 0 до 3
print(1 / a)
Traceback (most recent call last):
  File "main.py", line 27, in <module>
    print(1 / a)
ZeroDivisionError: division by zero
Если запустить эту программу несколько раз, то рано или поздно a получит значение 0, и получится «ошибка во время выполнения» типа ZeroDivisionError.

И ещё пример:

import math
import random

a = random.randint(-2, 2)  # случайное целое число от -2 до 2
# посчитаем квадратный корень из `a`
print(math.sqrt(a))  # sqrt() - от англ. square root, квадратный корень
Traceback (most recent call last):
  File "main.py", line 26, in <module>
    print(math.sqrt(a))
ValueError: math domain error
При попытке вычислить квадратный корень из отрицательного числа возникает ошибка типа ValueError. Она означает, что функция не может работать с таким значением аргумента.

Когда функция даёт сбой, Python создаёт особый объект, он называется исключение. При возникновении исключений программа останавливается, а в консоли появляется сообщение об ошибке.

Польза от исключений не только в том, что они информируют разработчика об ошибке. Исключение — это такой программный индикатор: «что-то пошло не так»; программа может «увидеть» исключение и среагировать на него по заданной инструкции. При возникновении исключения можно избежать остановки программы — для этого нужно написать код с инструкцией «что делать, если появилось исключение». Такой подход называют «перехватить исключение» — то есть вовремя отследить его и не допустить остановки программы.

Для перехвата исключений часто применяют конструкцию try - except: «попробуй (try) выполнить такую-то операцию, а если возникнет исключение (except) — выполни другую операцию». Исключения бывают разного типа, и инструкции по обработке исключений тоже можно устанавливать для каждого типа отдельно.

try:
    # Здесь написан код, который в некоторых ситуациях
    # может создать исключение (может "выбросить исключение", как говорят разработчики).
    # Программа попробует (try) выполнить этот код.
except TypeError1:
    # Здесь описываем, что следует делать,
    # если будет "выброшено" исключение типа TypeError1.
except TypeError2:
      # А здесь разработчик описывает, как быть, если перехвачено
    # исключение типа TypeError2.
Рассмотрим применение конструкции try - except на примере делёжки яблок между друзьями разных пользователей.

# вот функция, которая может выбросить исключение
def calc_share(apples, friends):
    # от строки откусываем число и приводим к типу int
    friends_number = int(friends.split()[0])
    return apples/friends_number

# есть 17 яблок
apples = 17

# будем считать, сколько достанется каждому другу
# вызовем функцию calc_share() для разных наших знакомых,
# с различным числом друзей
for friends in ['7 друзей', '2 друга', '0 друзей', 'один враг']:
        try:
                print('Каждому достанется по', calc_share(apples, friends), 'яблока')
        except ZeroDivisionError:
                print('На ноль делить нельзя.')
        except ValueError:
                print(f'Из строки "{friends}" не получилось достать число.')
Каждому достанется по 2.4285714285714284 яблока
Каждому достанется по 8.5 яблока
На ноль делить нельзя.
Из строки "один враг" не получилось достать число.
Задача №4
Напишите функцию what_weather(), которую затем будете использовать в коде Анфисы:

Выполните HTTP-запрос, поместив вызов функции get() внутрь блока try.
Значения URL и параметров получите из функций make_url() (в неё нужно передать нужный город как аргумент city) и make_parameters().
При «выбрасывании» исключения типа requests.ConnectionError — функция what_weather() должна возвращать сообщение об ошибке '<сетевая ошибка>'.
Если код HTTP-ответа равен 200 (всё хорошо), верните из функции текст ответа. В противном случае функция должна вернуть строку '<ошибка на сервере погоды>'.
import requests


cities = [
    'Омск',
    'Калининград',
    'Челябинск',
    'Владивосток',
    'Красноярск',
    'Москва',
    'Екатеринбург'
]


def make_url(city):
    # в URL задаём город, в котором узнаем погоду
    return f'http://wttr.in/{city}'


def make_parameters():
    params = {
        'format': 2,  # погода одной строкой
        'M': ''  # скорость ветра в "м/с"
    }
    return params


def what_weather(city):
    # Напишите тело этой функции.
    # Не изменяйте остальной код!

print('Погода в городах:')
for city in cities:
    print(city, what_weather(city))
